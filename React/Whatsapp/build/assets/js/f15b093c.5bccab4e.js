"use strict";(self.webpackChunkovrsea_whatsapp_tuto=self.webpackChunkovrsea_whatsapp_tuto||[]).push([[2292],{3905:(e,t,n)=>{n.d(t,{Zo:()=>c,kt:()=>m});var a=n(7294);function s(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?r(Object(n),!0).forEach((function(t){s(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function o(e,t){if(null==e)return{};var n,a,s=function(e,t){if(null==e)return{};var n,a,s={},r=Object.keys(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||(s[n]=e[n]);return s}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(s[n]=e[n])}return s}var l=a.createContext({}),p=function(e){var t=a.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},c=function(e){var t=p(e.components);return a.createElement(l.Provider,{value:t},e.children)},d={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},h=a.forwardRef((function(e,t){var n=e.components,s=e.mdxType,r=e.originalType,l=e.parentName,c=o(e,["components","mdxType","originalType","parentName"]),h=p(n),m=s,u=h["".concat(l,".").concat(m)]||h[m]||d[m]||r;return n?a.createElement(u,i(i({ref:t},c),{},{components:n})):a.createElement(u,i({ref:t},c))}));function m(e,t){var n=arguments,s=t&&t.mdxType;if("string"==typeof e||s){var r=n.length,i=new Array(r);i[0]=h;var o={};for(var l in t)hasOwnProperty.call(t,l)&&(o[l]=t[l]);o.originalType=e,o.mdxType="string"==typeof e?e:s,i[1]=o;for(var p=2;p<r;p++)i[p]=n[p];return a.createElement.apply(null,i)}return a.createElement.apply(null,n)}h.displayName="MDXCreateElement"},67:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>i,default:()=>d,frontMatter:()=>r,metadata:()=>o,toc:()=>p});var a=n(7462),s=(n(7294),n(3905));const r={sidebar_label:"Step 10: Live updates with GraphQL subscriptions",sidebar_position:10},i="Step 10: Live updates with GraphQL subscriptions",o={unversionedId:"tuto-whatsapp/step10",id:"tuto-whatsapp/step10",title:"Step 10: Live updates with GraphQL subscriptions",description:"[//]: # (head-end)",source:"@site/docs/tuto-whatsapp/step10.md",sourceDirName:"tuto-whatsapp",slug:"/tuto-whatsapp/step10",permalink:"/docs/next/tuto-whatsapp/step10",draft:!1,editUrl:"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/tuto-whatsapp/step10.md",tags:[],version:"current",sidebarPosition:10,frontMatter:{sidebar_label:"Step 10: Live updates with GraphQL subscriptions",sidebar_position:10},sidebar:"tutorialSidebar",previous:{title:"Step 9: Type safety with GraphQL Code Generator",permalink:"/docs/next/tuto-whatsapp/step9"},next:{title:"Step 11: Users",permalink:"/docs/next/tuto-whatsapp/step11"}},l={},p=[{value:"<strong>Server</strong> Step 7.1: Add subscription type with messageAdded",id:"server-step-71-add-subscription-type-with-messageadded",level:4},{value:"Changed schema/typeDefs.graphql",id:"changed-schematypedefsgraphql",level:5},{value:"<strong>Server</strong> Step 7.2: Provide a new instance of PubSub to context",id:"server-step-72-provide-a-new-instance-of-pubsub-to-context",level:4},{value:"Changed index.ts",id:"changed-indexts",level:5},{value:"<strong>Server</strong> Step 7.3: Define Context type",id:"server-step-73-define-context-type",level:4},{value:"Changed codegen.yml",id:"changed-codegenyml",level:5},{value:"Added context.ts",id:"added-contextts",level:5},{value:"<strong>Server</strong> Step 7.4: Publish message added event",id:"server-step-74-publish-message-added-event",level:4},{value:"Changed schema/resolvers.ts",id:"changed-schemaresolversts",level:5},{value:"Changed tests/mutations/addMessage.test.ts",id:"changed-testsmutationsaddmessagetestts",level:5},{value:"<strong>Server</strong> Step 7.5: Add Subscription.messageAdded resolver",id:"server-step-75-add-subscriptionmessageadded-resolver",level:4},{value:"Changed schema/resolvers.ts",id:"changed-schemaresolversts-1",level:5},{value:"<strong>Server</strong> Step 7.6: Install subscription handlers",id:"server-step-76-install-subscription-handlers",level:4},{value:"Changed index.ts",id:"changed-indexts-1",level:5},{value:"<strong>Client</strong> Step 10.1: Setup WS link",id:"client-step-101-setup-ws-link",level:4},{value:"Changed src/client.ts",id:"changed-srcclientts",level:5},{value:"<strong>Client</strong> Step 10.2: Add messageAdded subscription document",id:"client-step-102-add-messageadded-subscription-document",level:4},{value:"Added src/graphql/subscriptions/index.ts",id:"added-srcgraphqlsubscriptionsindexts",level:5},{value:"Added src/graphql/subscriptions/messageAdded.subscription.ts",id:"added-srcgraphqlsubscriptionsmessageaddedsubscriptionts",level:5},{value:"<strong>Client</strong> Step 10.3: Update cache on message added",id:"client-step-103-update-cache-on-message-added",level:4},{value:"Added src/services/cache.service.ts",id:"added-srcservicescacheservicets",level:5},{value:"<strong>Client</strong> Step 10.3: Update cache on message added",id:"client-step-103-update-cache-on-message-added-1",level:4},{value:"Changed src/components/ChatRoomScreen/index.tsx",id:"changed-srccomponentschatroomscreenindextsx",level:5},{value:"<strong>Server</strong> Step 7.7: Add Message.chat resolver",id:"server-step-77-add-messagechat-resolver",level:4},{value:"Changed schema/resolvers.ts",id:"changed-schemaresolversts-2",level:5},{value:"Changed schema/typeDefs.graphql",id:"changed-schematypedefsgraphql-1",level:5},{value:"<strong>Client</strong> Step 10.4: Add chat.id to message fragment",id:"client-step-104-add-chatid-to-message-fragment",level:4},{value:"Changed src/components/ChatRoomScreen/index.tsx",id:"changed-srccomponentschatroomscreenindextsx-1",level:5},{value:"Changed src/components/ChatsListScreen/ChatsList.test.tsx",id:"changed-srccomponentschatslistscreenchatslisttesttsx",level:5},{value:"Changed src/graphql/fragments/message.fragment.ts",id:"changed-srcgraphqlfragmentsmessagefragmentts",level:5},{value:"<strong>Client</strong> Step 10.5: Use cache service",id:"client-step-105-use-cache-service",level:4},{value:"Changed src/App.tsx",id:"changed-srcapptsx",level:5}],c={toc:p};function d(e){let{components:t,...n}=e;return(0,s.kt)("wrapper",(0,a.Z)({},c,n,{components:t,mdxType:"MDXLayout"}),(0,s.kt)("h1",{id:"step-10-live-updates-with-graphql-subscriptions"},"Step 10: Live updates with GraphQL subscriptions"),(0,s.kt)("p",null,"So far we've been developing the app and we've been treating it as if there's no other users; we're the only one exists.\nThis approach is true when we want to develop a UI and focus on UX, but comes a point where we need to start thinking on a macro level.\nOur app is social interactive, and if things work properly for me, it doesn't mean that it works properly to the fellow I'm chatting with.\nIt's inevitable to have an authentication system in our app, hence we need to take care of things before we get to that stage."),(0,s.kt)("p",null,"Try to open 2 instances of the app in 2 separate tabs/windows, and navigate into the same chat room.\nTry to send a message with one instance and notice that the second instance doesn't update unless we refresh the page."),(0,s.kt)("p",null,(0,s.kt)("img",{parentName:"p",src:"https://user-images.githubusercontent.com/7648874/55079371-fbd87080-50d6-11e9-8ade-5ffeed6eaf8d.gif",alt:"ezgif com-video-to-gif (2)"})),(0,s.kt)("p",null,"This issue is very important and should be addressed, because a chat is all about sending and receiving messages on a lively basis.\nThis issue was expected, as there's no mechanism that would trigger and listen to changes in the back-end.\nIn this chapter we're gonna address that issue by implementing exactly that mechanism."),(0,s.kt)("p",null,(0,s.kt)("strong",{parentName:"p"},"Introducing: GraphQL Subscriptions")),(0,s.kt)("p",null,(0,s.kt)("a",{parentName:"p",href:"https://github.com/apollographql/graphql-subscriptions"},"GraphQL subscriptions")," is a mechanism that works on ",(0,s.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/WebSocket"},"web-sockets")," and live communication; clients can subscribe to it and be notified regards specific changes that happen in the back-end. Notifications will be triggered manually by us and can be provided with parameters that provide additional information regards the triggered event. For example, a ",(0,s.kt)("inlineCode",{parentName:"p"},"messageAdded")," will be published with the new message, and will notify all clients who are subscribed to that event. Once the subscribers are notified, they can respond as they would like to, such as updating the UI."),(0,s.kt)("p",null,(0,s.kt)("img",{parentName:"p",src:"https://user-images.githubusercontent.com/7648874/55079462-30e4c300-50d7-11e9-8399-7706da2a9cff.png",alt:"subscription-notifications"})),(0,s.kt)("p",null,"A subscription is presented in our GraphQL schema as a separate type called ",(0,s.kt)("inlineCode",{parentName:"p"},"Subscription"),", where each field represents an event name along with its return type.\nLike any other GraphQL type, each field should be match with a resolver where we handle the request."),(0,s.kt)("p",null,"In this chapter we will implement the ",(0,s.kt)("inlineCode",{parentName:"p"},"messageAdded")," subscription, so users can be notified when it happens and update the messages list to contain the new message."),(0,s.kt)("p",null,(0,s.kt)("strong",{parentName:"p"},"Implementing a subscription")),(0,s.kt)("p",null,"We will start by creating a new ",(0,s.kt)("inlineCode",{parentName:"p"},"Subscription")," type in our GraphQL schema with the field ",(0,s.kt)("inlineCode",{parentName:"p"},"messageAdded"),":"),(0,s.kt)("h4",{id:"server-step-71-add-subscription-type-with-messageadded"},(0,s.kt)("a",{parentName:"h4",href:"https://github.com/Urigo/WhatsApp-Clone-Server/commit/8990384920d900deb8cd81cc13ca21689e2a9844"},(0,s.kt)("strong",{parentName:"a"},"Server")," Step 7.1: Add subscription type with messageAdded")),(0,s.kt)("h5",{id:"changed-schematypedefsgraphql"},"Changed schema","/","typeDefs.graphql"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-diff"},"@@ -23,3 +23,7 @@\n \u250a23\u250a23\u250atype Mutation {\n \u250a24\u250a24\u250a  addMessage(chatId: ID!, content: String!): Message\n \u250a25\u250a25\u250a}\n+\u250a  \u250a26\u250a\n+\u250a  \u250a27\u250atype Subscription {\n+\u250a  \u250a28\u250a  messageAdded: Message!\n+\u250a  \u250a29\u250a}\n")),(0,s.kt)("p",null,"Changes are triggered using an event-emitter like object called ",(0,s.kt)("inlineCode",{parentName:"p"},"PubSub"),". This can be done using the ",(0,s.kt)("inlineCode",{parentName:"p"},"PubSub.prototype.publish")," method. We will create a new instance of it and will provide it via the ",(0,s.kt)("a",{parentName:"p",href:"https://www.apollographql.com/docs/apollo-server/essentials/data#context"},"context")," - a common pattern for providing objects which are useful for the execution of the resolvers:"),(0,s.kt)("p",null,"TODO: Explain what the context is"),(0,s.kt)("h4",{id:"server-step-72-provide-a-new-instance-of-pubsub-to-context"},(0,s.kt)("a",{parentName:"h4",href:"https://github.com/Urigo/WhatsApp-Clone-Server/commit/5d81bbf9f06dfd084097d674d8dca9056bd226f6"},(0,s.kt)("strong",{parentName:"a"},"Server")," Step 7.2: Provide a new instance of PubSub to context")),(0,s.kt)("h5",{id:"changed-indexts"},"Changed index.ts"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-diff"},"@@ -1,4 +1,4 @@\n-\u250a1\u250a \u250aimport { ApolloServer, gql } from 'apollo-server-express';\n+\u250a \u250a1\u250aimport { ApolloServer, gql, PubSub } from 'apollo-server-express';\n \u250a2\u250a2\u250aimport cors from 'cors';\n \u250a3\u250a3\u250aimport express from 'express';\n \u250a4\u250a4\u250aimport schema from './schema';\n")),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-diff"},"@@ -12,7 +12,11 @@\n \u250a12\u250a12\u250a  res.send('pong');\n \u250a13\u250a13\u250a});\n \u250a14\u250a14\u250a\n-\u250a15\u250a  \u250aconst server = new ApolloServer({ schema });\n+\u250a  \u250a15\u250aconst pubsub = new PubSub();\n+\u250a  \u250a16\u250aconst server = new ApolloServer({\n+\u250a  \u250a17\u250a  schema,\n+\u250a  \u250a18\u250a  context: () => ({ pubsub }),\n+\u250a  \u250a19\u250a});\n \u250a16\u250a20\u250a\n \u250a17\u250a21\u250aserver.applyMiddleware({\n \u250a18\u250a22\u250a  app,\n")),(0,s.kt)("p",null,"Inside the ",(0,s.kt)("inlineCode",{parentName:"p"},"addMessage")," resolver we will publish a new event called ",(0,s.kt)("inlineCode",{parentName:"p"},"messageAdded"),". The 3rd argument of the resolver will be the context object that we've just defined in the previous step, where we can use the pubsub instance. The TypeScript type of our context can be directly defined and generated by CodeGen through the ",(0,s.kt)("inlineCode",{parentName:"p"},"codegen.yml")," file. This can be specified under the ",(0,s.kt)("inlineCode",{parentName:"p"},"ContextType")," field with the file path that contains the context followed by the name of the exported object, like so:"),(0,s.kt)("h4",{id:"server-step-73-define-context-type"},(0,s.kt)("a",{parentName:"h4",href:"https://github.com/Urigo/WhatsApp-Clone-Server/commit/6521a3d39c1e50291100943e7577fa18eb0205cc"},(0,s.kt)("strong",{parentName:"a"},"Server")," Step 7.3: Define Context type")),(0,s.kt)("h5",{id:"changed-codegenyml"},"Changed codegen.yml"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-diff"},"@@ -6,6 +6,7 @@\n \u250a 6\u250a 6\u250a      - typescript\n \u250a 7\u250a 7\u250a      - typescript-resolvers\n \u250a 8\u250a 8\u250a    config:\n+\u250a  \u250a 9\u250a      contextType: ../context#MyContext\n \u250a 9\u250a10\u250a      mappers:\n \u250a10\u250a11\u250a        # import { Message } from '../db'\n \u250a11\u250a12\u250a        # The root types of Message resolvers\n")),(0,s.kt)("h5",{id:"added-contextts"},"Added context.ts"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-diff"},"@@ -0,0 +1,5 @@\n+\u250a \u250a1\u250aimport { PubSub } from 'apollo-server-express';\n+\u250a \u250a2\u250a\n+\u250a \u250a3\u250aexport type MyContext = {\n+\u250a \u250a4\u250a  pubsub: PubSub;\n+\u250a \u250a5\u250a};\n")),(0,s.kt)("p",null,"The event will be published right after the message was pushed into the messages collection, because order is a crucial thing. We don't want to notify our users unless the change has been made. The event will have a single parameter which represents the new message."),(0,s.kt)("h4",{id:"server-step-74-publish-message-added-event"},(0,s.kt)("a",{parentName:"h4",href:"https://github.com/Urigo/WhatsApp-Clone-Server/commit/a33a9f4d7fa206218249e38024ed98e2cbc6b24c"},(0,s.kt)("strong",{parentName:"a"},"Server")," Step 7.4: Publish message added event")),(0,s.kt)("h5",{id:"changed-schemaresolversts"},"Changed schema","/","resolvers.ts"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-diff"},"@@ -29,7 +29,7 @@\n \u250a29\u250a29\u250a  },\n \u250a30\u250a30\u250a\n \u250a31\u250a31\u250a  Mutation: {\n-\u250a32\u250a  \u250a    addMessage(root, { chatId, content }) {\n+\u250a  \u250a32\u250a    addMessage(root, { chatId, content }, { pubsub }) {\n \u250a33\u250a33\u250a      const chatIndex = chats.findIndex((c) => c.id === chatId);\n \u250a34\u250a34\u250a\n \u250a35\u250a35\u250a      if (chatIndex === -1) return null;\n")),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-diff"},"@@ -52,6 +52,10 @@\n \u250a52\u250a52\u250a      chats.splice(chatIndex, 1);\n \u250a53\u250a53\u250a      chats.unshift(chat);\n \u250a54\u250a54\u250a\n+\u250a  \u250a55\u250a      pubsub.publish('messageAdded', {\n+\u250a  \u250a56\u250a        messageAdded: message,\n+\u250a  \u250a57\u250a      });\n+\u250a  \u250a58\u250a\n \u250a55\u250a59\u250a      return message;\n \u250a56\u250a60\u250a    },\n \u250a57\u250a61\u250a  },\n")),(0,s.kt)("h5",{id:"changed-testsmutationsaddmessagetestts"},"Changed tests","/","mutations","/","addMessage.test.ts"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-diff"},"@@ -1,5 +1,5 @@\n \u250a1\u250a1\u250aimport { createTestClient } from 'apollo-server-testing';\n-\u250a2\u250a \u250aimport { ApolloServer, gql } from 'apollo-server-express';\n+\u250a \u250a2\u250aimport { ApolloServer, PubSub, gql } from 'apollo-server-express';\n \u250a3\u250a3\u250aimport schema from '../../schema';\n \u250a4\u250a4\u250aimport { resetDb } from '../../db';\n \u250a5\u250a5\u250a\n")),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-diff"},"@@ -7,7 +7,10 @@\n \u250a 7\u250a 7\u250a  beforeEach(resetDb);\n \u250a 8\u250a 8\u250a\n \u250a 9\u250a 9\u250a  it('should add message to specified chat', async () => {\n-\u250a10\u250a  \u250a    const server = new ApolloServer({ schema });\n+\u250a  \u250a10\u250a    const server = new ApolloServer({\n+\u250a  \u250a11\u250a      schema,\n+\u250a  \u250a12\u250a      context: () => ({ pubsub: new PubSub() }),\n+\u250a  \u250a13\u250a    });\n \u250a11\u250a14\u250a\n \u250a12\u250a15\u250a    const { query, mutate } = createTestClient(server);\n")),(0,s.kt)("p",null,"A subscription resolver behaves differently and thus should be implemented differently. Using the ",(0,s.kt)("inlineCode",{parentName:"p"},"pubsub.asyncIterator")," instance, we can specify which events are relevant for the subscription, for example, all clients who are subscribers of the ",(0,s.kt)("inlineCode",{parentName:"p"},"chatUpdated")," subscription will be notified when ",(0,s.kt)("inlineCode",{parentName:"p"},"messageAdded"),", ",(0,s.kt)("inlineCode",{parentName:"p"},"messageRemoved")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"chatInfoChanged")," events were triggered. For now, we will have a 1 to 1 relationship between the ",(0,s.kt)("inlineCode",{parentName:"p"},"messageAdded")," event and ",(0,s.kt)("inlineCode",{parentName:"p"},"messageAdded")," subscription. In code, it should look like this:"),(0,s.kt)("h4",{id:"server-step-75-add-subscriptionmessageadded-resolver"},(0,s.kt)("a",{parentName:"h4",href:"https://github.com/Urigo/WhatsApp-Clone-Server/commit/3481d1c769b2e488bbe71474b43347c4ea7acbf2"},(0,s.kt)("strong",{parentName:"a"},"Server")," Step 7.5: Add Subscription.messageAdded resolver")),(0,s.kt)("h5",{id:"changed-schemaresolversts-1"},"Changed schema","/","resolvers.ts"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-diff"},"@@ -59,6 +59,13 @@\n \u250a59\u250a59\u250a      return message;\n \u250a60\u250a60\u250a    },\n \u250a61\u250a61\u250a  },\n+\u250a  \u250a62\u250a\n+\u250a  \u250a63\u250a  Subscription: {\n+\u250a  \u250a64\u250a    messageAdded: {\n+\u250a  \u250a65\u250a      subscribe: (root, args, { pubsub }) =>\n+\u250a  \u250a66\u250a        pubsub.asyncIterator('messageAdded'),\n+\u250a  \u250a67\u250a    },\n+\u250a  \u250a68\u250a  },\n \u250a62\u250a69\u250a};\n \u250a63\u250a70\u250a\n \u250a64\u250a71\u250aexport default resolvers;\n")),(0,s.kt)("p",null,"The idea behind the ",(0,s.kt)("inlineCode",{parentName:"p"},"pubsub.asyncIterator")," method is that it returns an ",(0,s.kt)("a",{parentName:"p",href:"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Iterators_and_Generators#Iterators"},(0,s.kt)("inlineCode",{parentName:"a"},"Iterator"))," like object, where each value is a promise that will be resolved when the relevant events are triggered. By default, the parameter that has a similar name to the subscription will be returned as a response, e.g. ",(0,s.kt)("inlineCode",{parentName:"p"},"messageAdded")," parameter will be sent back to the subscribers. This behavior can be modified as explained ",(0,s.kt)("a",{parentName:"p",href:"https://github.com/apollographql/graphql-subscriptions#payload-manipulation"},"here"),", but it's very unlikely and not necessary for our use case."),(0,s.kt)("p",null,"As mentioned at the beginning of this article, there needs to be an open connection between the client and the server so live updates can happen. There are serveral methods for doing so, but the 2 most popular ones are:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},"Based on polling with HTTP protocol"),(0,s.kt)("li",{parentName:"ul"},"Based on web-sockets (WS protocol)")),(0,s.kt)("p",null,"HTTP polling means that each amount of time an HTTP request will be made to the server where potential changes can be sent back to us at any given time. HTTP requests are very reliable, but the problem with them is that they contain a lot of information in their headers, so even if we sent an empty request, it might be still very heavy due to cookies, user-agent, language, request type, etc."),(0,s.kt)("p",null,"With web-sockets, once a connection has been established, it will remain open and it will only send the information which is relevant for the current session, so it's much faster.\nThe communication between the server and the client is bi-directional when it comes to web-sockets, which means that a user can spontaneously receive information from the server, as long as the communication channel remains open."),(0,s.kt)("blockquote",null,(0,s.kt)("p",{parentName:"blockquote"},"More information about the advantages of Web Sockets over HTTP can be found at ",(0,s.kt)("a",{parentName:"p",href:"http://websocket.org/quantum.html"},"websocket.org"))),(0,s.kt)("p",null,"The subscription mechanism can be installed using the ",(0,s.kt)("inlineCode",{parentName:"p"},"server.installSubscriptionHandlers"),". It will use the WS protocol by default and will fallback to HTTP polling if there were troubles establishing a connection via WS protocol:"),(0,s.kt)("h4",{id:"server-step-76-install-subscription-handlers"},(0,s.kt)("a",{parentName:"h4",href:"https://github.com/Urigo/WhatsApp-Clone-Server/commit/dedd1d002c79b3b6ab4685a39f3192e11fa74942"},(0,s.kt)("strong",{parentName:"a"},"Server")," Step 7.6: Install subscription handlers")),(0,s.kt)("h5",{id:"changed-indexts-1"},"Changed index.ts"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-diff"},"@@ -1,6 +1,7 @@\n \u250a1\u250a1\u250aimport { ApolloServer, gql, PubSub } from 'apollo-server-express';\n \u250a2\u250a2\u250aimport cors from 'cors';\n \u250a3\u250a3\u250aimport express from 'express';\n+\u250a \u250a4\u250aimport http from 'http';\n \u250a4\u250a5\u250aimport schema from './schema';\n \u250a5\u250a6\u250a\n \u250a6\u250a7\u250aconst app = express();\n")),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-diff"},"@@ -23,8 +24,11 @@\n \u250a23\u250a24\u250a  path: '/graphql',\n \u250a24\u250a25\u250a});\n \u250a25\u250a26\u250a\n+\u250a  \u250a27\u250aconst httpServer = http.createServer(app);\n+\u250a  \u250a28\u250aserver.installSubscriptionHandlers(httpServer);\n+\u250a  \u250a29\u250a\n \u250a26\u250a30\u250aconst port = process.env.PORT || 4000;\n \u250a27\u250a31\u250a\n-\u250a28\u250a  \u250aapp.listen(port, () => {\n+\u250a  \u250a32\u250ahttpServer.listen(port, () => {\n \u250a29\u250a33\u250a  console.log(`Server is listening on port ${port}`);\n \u250a30\u250a34\u250a});\n")),(0,s.kt)("p",null,"Now we have everything set and we can start listening to subscriptions and react to to triggered changes."),(0,s.kt)("p",null,(0,s.kt)("strong",{parentName:"p"},"Using subscriptions")),(0,s.kt)("p",null,"To support subscriptions we need to establish a WS connection. For that we will need to update our Apollo client. We will install a couple of packages that will enable such feature:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre"},"$ yarn add subscriptions-transport-ws apollo-link apollo-link-ws apollo-utilities\n")),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("a",{parentName:"li",href:"https://www.npmjs.com/package/subscriptions-transport-ws"},(0,s.kt)("inlineCode",{parentName:"a"},"subscriptions-transport-ws"))," - a transport layer that understands how client and GraphQL API communicates with each other. The spec has GQL_INIT GQL_UPDATE GQL_DATA events."),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("a",{parentName:"li",href:"https://www.npmjs.com/package/apollo-link-ws"},(0,s.kt)("inlineCode",{parentName:"a"},"apollo-link-ws"))," - Will establish a WS connection."),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("a",{parentName:"li",href:"https://www.npmjs.com/package/apollo-link"},(0,s.kt)("inlineCode",{parentName:"a"},"apollo-link"))," - Will enable WS and HTTP connections co-exist in a single client."),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("a",{parentName:"li",href:"https://www.npmjs.com/package/apollo-utilities"},(0,s.kt)("inlineCode",{parentName:"a"},"apollo-utilities"))," - Includes utility functions that will help us analyze a GraphQL AST.")),(0,s.kt)("p",null,"The WS url can be composed by simply running a regular expression over the ",(0,s.kt)("inlineCode",{parentName:"p"},"REACT_APP_SERVER_URL")," environment variable and is unnecessary to be stored separately. Here's how our new client should look like: \\"),(0,s.kt)("h4",{id:"client-step-101-setup-ws-link"},(0,s.kt)("a",{parentName:"h4",href:"https://github.com/Urigo/WhatsApp-Clone-Client-React/commit/88f09c024aa2402237bb3fdaeac7409673319290"},(0,s.kt)("strong",{parentName:"a"},"Client")," Step 10.1: Setup WS link")),(0,s.kt)("h5",{id:"changed-srcclientts"},"Changed src","/","client.ts"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-diff"},"@@ -1,16 +1,48 @@\n \u250a 1\u250a 1\u250aimport { InMemoryCache } from 'apollo-cache-inmemory';\n \u250a 2\u250a 2\u250aimport { ApolloClient } from 'apollo-client';\n+\u250a  \u250a 3\u250aimport { getMainDefinition } from 'apollo-utilities';\n \u250a 3\u250a 4\u250aimport { HttpLink } from 'apollo-link-http';\n+\u250a  \u250a 5\u250aimport { WebSocketLink } from 'apollo-link-ws';\n+\u250a  \u250a 6\u250aimport { ApolloLink, split } from 'apollo-link';\n \u250a 4\u250a 7\u250a\n \u250a 5\u250a 8\u250aconst httpUri = process.env.REACT_APP_SERVER_URL + '/graphql';\n+\u250a  \u250a 9\u250aconst wsUri = httpUri.replace(/^https?/, 'ws');\n \u250a 6\u250a10\u250a\n \u250a 7\u250a11\u250aconst httpLink = new HttpLink({\n \u250a 8\u250a12\u250a  uri: httpUri,\n \u250a 9\u250a13\u250a});\n \u250a10\u250a14\u250a\n+\u250a  \u250a15\u250aconst wsLink = new WebSocketLink({\n+\u250a  \u250a16\u250a  uri: wsUri,\n+\u250a  \u250a17\u250a  options: {\n+\u250a  \u250a18\u250a    // Automatic reconnect in case of connection error\n+\u250a  \u250a19\u250a    reconnect: true,\n+\u250a  \u250a20\u250a  },\n+\u250a  \u250a21\u250a});\n+\u250a  \u250a22\u250a\n+\u250a  \u250a23\u250a/**\n+\u250a  \u250a24\u250a * Fix error typing in `split` method in `apollo-link`\n+\u250a  \u250a25\u250a * Related issue https://github.com/apollographql/apollo-client/issues/3090\n+\u250a  \u250a26\u250a */\n+\u250a  \u250a27\u250aexport interface Definition {\n+\u250a  \u250a28\u250a  kind: string;\n+\u250a  \u250a29\u250a  operation?: string;\n+\u250a  \u250a30\u250a}\n+\u250a  \u250a31\u250aconst terminatingLink = split(\n+\u250a  \u250a32\u250a  ({ query }) => {\n+\u250a  \u250a33\u250a    const { kind, operation }: Definition = getMainDefinition(query);\n+\u250a  \u250a34\u250a    // If this is a subscription query, use wsLink, otherwise use httpLink\n+\u250a  \u250a35\u250a    return kind === 'OperationDefinition' && operation === 'subscription';\n+\u250a  \u250a36\u250a  },\n+\u250a  \u250a37\u250a  wsLink,\n+\u250a  \u250a38\u250a  httpLink\n+\u250a  \u250a39\u250a);\n+\u250a  \u250a40\u250a\n+\u250a  \u250a41\u250aconst link = ApolloLink.from([terminatingLink]);\n+\u250a  \u250a42\u250a\n \u250a11\u250a43\u250aconst inMemoryCache = new InMemoryCache();\n \u250a12\u250a44\u250a\n \u250a13\u250a45\u250aexport default new ApolloClient({\n-\u250a14\u250a  \u250a  link: httpLink,\n+\u250a  \u250a46\u250a  link,\n \u250a15\u250a47\u250a  cache: inMemoryCache,\n \u250a16\u250a48\u250a});\n")),(0,s.kt)("p",null,"Our subscription listeners should live globally across our application and shouldn't be bound to a specific component, thus we will create an external service which will be responsible of doing so. Using that service, we will update our GraphQL data-store any time a new message has been added. We will define a ",(0,s.kt)("inlineCode",{parentName:"p"},"messageAdded")," subscription in a dedicated file under the ",(0,s.kt)("inlineCode",{parentName:"p"},"src/graphql/subscriptions")," dir where all our subscriptions will be defined and exported:"),(0,s.kt)("h4",{id:"client-step-102-add-messageadded-subscription-document"},(0,s.kt)("a",{parentName:"h4",href:"https://github.com/Urigo/WhatsApp-Clone-Client-React/commit/6f10fe2a180fa8c2681a88a42c495587476331ac"},(0,s.kt)("strong",{parentName:"a"},"Client")," Step 10.2: Add messageAdded subscription document")),(0,s.kt)("h5",{id:"added-srcgraphqlsubscriptionsindexts"},"Added src","/","graphql","/","subscriptions","/","index.ts"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-diff"},"@@ -0,0 +1 @@\n+\u250a \u250a1\u250aexport { default as messageAdded } from './messageAdded.subscription';\n")),(0,s.kt)("h5",{id:"added-srcgraphqlsubscriptionsmessageaddedsubscriptionts"},"Added src","/","graphql","/","subscriptions","/","messageAdded.subscription.ts"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-diff"},"@@ -0,0 +1,11 @@\n+\u250a  \u250a 1\u250aimport gql from 'graphql-tag';\n+\u250a  \u250a 2\u250aimport * as fragments from '../fragments';\n+\u250a  \u250a 3\u250a\n+\u250a  \u250a 4\u250aexport default gql`\n+\u250a  \u250a 5\u250a  subscription MessageAdded {\n+\u250a  \u250a 6\u250a    messageAdded {\n+\u250a  \u250a 7\u250a      ...Message\n+\u250a  \u250a 8\u250a    }\n+\u250a  \u250a 9\u250a  }\n+\u250a  \u250a10\u250a  ${fragments.message}\n+\u250a  \u250a11\u250a`;\n")),(0,s.kt)("p",null,"Now we will create the service under the path ",(0,s.kt)("inlineCode",{parentName:"p"},"services/cache.service.ts"),".\nLike any other GraphQL operation, ",(0,s.kt)("inlineCode",{parentName:"p"},"@apollo/react-hooks")," provides us with a dedicated React hook for subscriptions called ",(0,s.kt)("inlineCode",{parentName:"p"},"useSubscription"),"."),(0,s.kt)("p",null,"Given the subscription document and the ",(0,s.kt)("inlineCode",{parentName:"p"},"onSubscriptionData")," callback we can handle incoming changes.\nWe will be using GraphQL Code Generator to generate typed subscription hooks, as the ",(0,s.kt)("inlineCode",{parentName:"p"},"typescript-react-apollo")," plug-in supports it right out of the box."),(0,s.kt)("p",null,"So let's run the code generation command:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre"},"$ yarn codegen\n")),(0,s.kt)("p",null,"Now we can import and use the newly generated hook ",(0,s.kt)("inlineCode",{parentName:"p"},"useMessageAddedSubscription")," in the ",(0,s.kt)("inlineCode",{parentName:"p"},"cache.service"),". Like mentioned earlier, we will be using the ",(0,s.kt)("inlineCode",{parentName:"p"},"onSubscriptionData")," callback to retrieve the change that was sent by the server and we will use it to re-write our cache. In this case we will be writing a new fragment for the incoming message, and we will update the correlated chat:"),(0,s.kt)("h4",{id:"client-step-103-update-cache-on-message-added"},(0,s.kt)("a",{parentName:"h4",href:"https://github.com/Urigo/WhatsApp-Clone-Client-React/commit/11fe22d2609c8e2afd44950938c47859d8c95382"},(0,s.kt)("strong",{parentName:"a"},"Client")," Step 10.3: Update cache on message added")),(0,s.kt)("h5",{id:"added-srcservicescacheservicets"},"Added src","/","services","/","cache.service.ts"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-diff"},"@@ -0,0 +1,92 @@\n+\u250a  \u250a 1\u250aimport { DataProxy } from 'apollo-cache';\n+\u250a  \u250a 2\u250aimport { defaultDataIdFromObject } from 'apollo-cache-inmemory';\n+\u250a  \u250a 3\u250aimport * as fragments from '../graphql/fragments';\n+\u250a  \u250a 4\u250aimport * as queries from '../graphql/queries';\n+\u250a  \u250a 5\u250aimport {\n+\u250a  \u250a 6\u250a  MessageFragment,\n+\u250a  \u250a 7\u250a  useMessageAddedSubscription,\n+\u250a  \u250a 8\u250a  ChatsQuery,\n+\u250a  \u250a 9\u250a} from '../graphql/types';\n+\u250a  \u250a10\u250a\n+\u250a  \u250a11\u250atype Client = Pick<\n+\u250a  \u250a12\u250a  DataProxy,\n+\u250a  \u250a13\u250a  'readFragment' | 'writeFragment' | 'readQuery' | 'writeQuery'\n+\u250a  \u250a14\u250a>;\n+\u250a  \u250a15\u250a\n+\u250a  \u250a16\u250aexport const useCacheService = () => {\n+\u250a  \u250a17\u250a  useMessageAddedSubscription({\n+\u250a  \u250a18\u250a    onSubscriptionData: ({ client, subscriptionData: { data } }) => {\n+\u250a  \u250a19\u250a      if (data) {\n+\u250a  \u250a20\u250a        writeMessage(client, data.messageAdded);\n+\u250a  \u250a21\u250a      }\n+\u250a  \u250a22\u250a    },\n+\u250a  \u250a23\u250a  });\n+\u250a  \u250a24\u250a};\n+\u250a  \u250a25\u250a\n+\u250a  \u250a26\u250aexport const writeMessage = (client: Client, message: MessageFragment) => {\n+\u250a  \u250a27\u250a  type FullChat = { [key: string]: any };\n+\u250a  \u250a28\u250a  let fullChat;\n+\u250a  \u250a29\u250a\n+\u250a  \u250a30\u250a  const chatIdFromStore = defaultDataIdFromObject(message.chat);\n+\u250a  \u250a31\u250a\n+\u250a  \u250a32\u250a  if (chatIdFromStore === null) {\n+\u250a  \u250a33\u250a    return;\n+\u250a  \u250a34\u250a  }\n+\u250a  \u250a35\u250a  try {\n+\u250a  \u250a36\u250a    fullChat = client.readFragment<FullChat>({\n+\u250a  \u250a37\u250a      id: chatIdFromStore,\n+\u250a  \u250a38\u250a      fragment: fragments.fullChat,\n+\u250a  \u250a39\u250a      fragmentName: 'FullChat',\n+\u250a  \u250a40\u250a    });\n+\u250a  \u250a41\u250a  } catch (e) {\n+\u250a  \u250a42\u250a    return;\n+\u250a  \u250a43\u250a  }\n+\u250a  \u250a44\u250a\n+\u250a  \u250a45\u250a  if (fullChat === null || fullChat.messages === null) {\n+\u250a  \u250a46\u250a    return;\n+\u250a  \u250a47\u250a  }\n+\u250a  \u250a48\u250a  if (fullChat.messages.some((m: any) => m.id === message.id)) return;\n+\u250a  \u250a49\u250a\n+\u250a  \u250a50\u250a  fullChat.messages.push(message);\n+\u250a  \u250a51\u250a  fullChat.lastMessage = message;\n+\u250a  \u250a52\u250a\n+\u250a  \u250a53\u250a  client.writeFragment({\n+\u250a  \u250a54\u250a    id: chatIdFromStore,\n+\u250a  \u250a55\u250a    fragment: fragments.fullChat,\n+\u250a  \u250a56\u250a    fragmentName: 'FullChat',\n+\u250a  \u250a57\u250a    data: fullChat,\n+\u250a  \u250a58\u250a  });\n+\u250a  \u250a59\u250a\n+\u250a  \u250a60\u250a  let data;\n+\u250a  \u250a61\u250a  try {\n+\u250a  \u250a62\u250a    data = client.readQuery<ChatsQuery>({\n+\u250a  \u250a63\u250a      query: queries.chats,\n+\u250a  \u250a64\u250a    });\n+\u250a  \u250a65\u250a  } catch (e) {\n+\u250a  \u250a66\u250a    return;\n+\u250a  \u250a67\u250a  }\n+\u250a  \u250a68\u250a\n+\u250a  \u250a69\u250a  if (!data || data === null) {\n+\u250a  \u250a70\u250a    return null;\n+\u250a  \u250a71\u250a  }\n+\u250a  \u250a72\u250a  if (!data.chats || data.chats === undefined) {\n+\u250a  \u250a73\u250a    return null;\n+\u250a  \u250a74\u250a  }\n+\u250a  \u250a75\u250a  const chats = data.chats;\n+\u250a  \u250a76\u250a\n+\u250a  \u250a77\u250a  const chatIndex = chats.findIndex((c: any) => {\n+\u250a  \u250a78\u250a    if (message === null || message.chat === null) return -1;\n+\u250a  \u250a79\u250a    return c.id === message?.chat?.id;\n+\u250a  \u250a80\u250a  });\n+\u250a  \u250a81\u250a  if (chatIndex === -1) return;\n+\u250a  \u250a82\u250a  const chatWhereAdded = chats[chatIndex];\n+\u250a  \u250a83\u250a\n+\u250a  \u250a84\u250a  // The chat will appear at the top of the ChatsList component\n+\u250a  \u250a85\u250a  chats.splice(chatIndex, 1);\n+\u250a  \u250a86\u250a  chats.unshift(chatWhereAdded);\n+\u250a  \u250a87\u250a\n+\u250a  \u250a88\u250a  client.writeQuery({\n+\u250a  \u250a89\u250a    query: queries.chats,\n+\u250a  \u250a90\u250a    data: { chats: chats },\n+\u250a  \u250a91\u250a  });\n+\u250a  \u250a92\u250a};\n")),(0,s.kt)("p",null,"We will also use the exported ",(0,s.kt)("inlineCode",{parentName:"p"},"writeMessage()")," function in the ",(0,s.kt)("inlineCode",{parentName:"p"},"ChatRoomScreen")," so we won't have any code duplications:"),(0,s.kt)("h4",{id:"client-step-103-update-cache-on-message-added-1"},(0,s.kt)("a",{parentName:"h4",href:"https://github.com/Urigo/WhatsApp-Clone-Client-React/commit/11fe22d2609c8e2afd44950938c47859d8c95382"},(0,s.kt)("strong",{parentName:"a"},"Client")," Step 10.3: Update cache on message added")),(0,s.kt)("h5",{id:"changed-srccomponentschatroomscreenindextsx"},"Changed src","/","components","/","ChatRoomScreen","/","index.tsx"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-diff"},"@@ -1,4 +1,3 @@\n-\u250a1\u250a \u250aimport { defaultDataIdFromObject } from 'apollo-cache-inmemory';\n \u250a2\u250a1\u250aimport gql from 'graphql-tag';\n \u250a3\u250a2\u250aimport React from 'react';\n \u250a4\u250a3\u250aimport { useCallback } from 'react';\n")),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-diff"},"@@ -7,13 +6,9 @@\n \u250a 7\u250a 6\u250aimport MessageInput from './MessageInput';\n \u250a 8\u250a 7\u250aimport MessagesList from './MessagesList';\n \u250a 9\u250a 8\u250aimport { useParams } from 'react-dom-router';\n-\u250a10\u250a  \u250aimport {\n-\u250a11\u250a  \u250a  ChatsQuery,\n-\u250a12\u250a  \u250a  useGetChatQuery,\n-\u250a13\u250a  \u250a  useAddMessageMutation,\n-\u250a14\u250a  \u250a} from '../../graphql/types';\n-\u250a15\u250a  \u250aimport * as queries from '../../graphql/queries';\n+\u250a  \u250a 9\u250aimport { useGetChatQuery, useAddMessageMutation } from '../../graphql/types';\n \u250a16\u250a10\u250aimport * as fragments from '../../graphql/fragments';\n+\u250a  \u250a11\u250aimport { writeMessage } from '../../services/cache.service';\n \u250a17\u250a12\u250a\n \u250a18\u250a13\u250aconst Container = styled.div`\n \u250a19\u250a14\u250a  background: url(/assets/chat-background.jpg);\n")),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-diff"},"@@ -47,10 +42,6 @@\n \u250a49\u250a44\u250a\n-\u250a50\u250a  \u250ainterface ChatsResult {\n-\u250a51\u250a  \u250a  chats: any[];\n-\u250a52\u250a  \u250a}\n-\u250a53\u250a  \u250a\n \u250a54\u250a45\u250aconst ChatRoomScreen: React.FC = () =>\n")),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-diff"},"@@ -82,73 +73,7 @@\n \u250a 82\u250a 73\u250a        },\n \u250a 83\u250a 74\u250a        update: (client, { data }) => {\n \u250a 84\u250a 75\u250a          if (data && data.addMessage) {\n-\u250a 85\u250a   \u250a            type FullChat = { [key: string]: any };\n-\u250a 86\u250a   \u250a            let fullChat;\n-\u250a 87\u250a   \u250a            const chatIdFromStore = defaultDataIdFromObject(chat);\n-\u250a 88\u250a   \u250a\n-\u250a 89\u250a   \u250a            if (chatIdFromStore === null) {\n-\u250a 90\u250a   \u250a              return;\n-\u250a 91\u250a   \u250a            }\n-\u250a 92\u250a   \u250a            try {\n-\u250a 93\u250a   \u250a              fullChat = client.readFragment<FullChat>({\n-\u250a 94\u250a   \u250a                id: chatIdFromStore,\n-\u250a 95\u250a   \u250a                fragment: fragments.fullChat,\n-\u250a 96\u250a   \u250a                fragmentName: 'FullChat',\n-\u250a 97\u250a   \u250a              });\n-\u250a 98\u250a   \u250a            } catch (e) {\n-\u250a 99\u250a   \u250a              return;\n-\u250a100\u250a   \u250a            }\n-\u250a101\u250a   \u250a\n-\u250a102\u250a   \u250a            if (fullChat === null || fullChat.messages === null) {\n-\u250a103\u250a   \u250a              return;\n-\u250a104\u250a   \u250a            }\n-\u250a105\u250a   \u250a            if (\n-\u250a106\u250a   \u250a              fullChat.messages.some(\n-\u250a107\u250a   \u250a                (currentMessage: any) =>\n-\u250a108\u250a   \u250a                  data.addMessage && currentMessage.id === data.addMessage.id\n-\u250a109\u250a   \u250a              )\n-\u250a110\u250a   \u250a            ) {\n-\u250a111\u250a   \u250a              return;\n-\u250a112\u250a   \u250a            }\n-\u250a113\u250a   \u250a\n-\u250a114\u250a   \u250a            fullChat.messages.push(data.addMessage);\n-\u250a115\u250a   \u250a            fullChat.lastMessage = data.addMessage;\n-\u250a116\u250a   \u250a\n-\u250a117\u250a   \u250a            client.writeFragment({\n-\u250a118\u250a   \u250a              id: chatIdFromStore,\n-\u250a119\u250a   \u250a              fragment: fragments.fullChat,\n-\u250a120\u250a   \u250a              fragmentName: 'FullChat',\n-\u250a121\u250a   \u250a              data: fullChat,\n-\u250a122\u250a   \u250a            });\n-\u250a123\u250a   \u250a\n-\u250a124\u250a   \u250a            let clientChatsData: ChatsQuery | null;\n-\u250a125\u250a   \u250a            try {\n-\u250a126\u250a   \u250a              clientChatsData = client.readQuery({\n-\u250a127\u250a   \u250a                query: queries.chats,\n-\u250a128\u250a   \u250a              });\n-\u250a129\u250a   \u250a            } catch (e) {\n-\u250a130\u250a   \u250a              return;\n-\u250a131\u250a   \u250a            }\n-\u250a132\u250a   \u250a\n-\u250a133\u250a   \u250a            if (!clientChatsData || !clientChatsData.chats) {\n-\u250a134\u250a   \u250a              return null;\n-\u250a135\u250a   \u250a            }\n-\u250a136\u250a   \u250a            const chats = clientChatsData.chats;\n-\u250a137\u250a   \u250a\n-\u250a138\u250a   \u250a            const chatIndex = chats.findIndex(\n-\u250a139\u250a   \u250a              (currentChat: any) => currentChat.id === chatId\n-\u250a140\u250a   \u250a            );\n-\u250a141\u250a   \u250a            if (chatIndex === -1) return;\n-\u250a142\u250a   \u250a            const chatWhereAdded = chats[chatIndex];\n-\u250a143\u250a   \u250a\n-\u250a144\u250a   \u250a            // The chat will appear at the top of the ChatsList component\n-\u250a145\u250a   \u250a            chats.splice(chatIndex, 1);\n-\u250a146\u250a   \u250a            chats.unshift(chatWhereAdded);\n-\u250a147\u250a   \u250a\n-\u250a148\u250a   \u250a            client.writeQuery({\n-\u250a149\u250a   \u250a              query: queries.chats,\n-\u250a150\u250a   \u250a              data: { chats: chats },\n-\u250a151\u250a   \u250a            });\n+\u250a   \u250a 76\u250a            writeMessage(client, data.addMessage);\n \u250a152\u250a 77\u250a          }\n \u250a153\u250a 78\u250a        },\n \u250a154\u250a 79\u250a      });\n")),(0,s.kt)("p",null,"One thing missing that you might notice is that we're trying to retrieve the chat from the received message, unfortunately our GraphQL schema doesn't support it and we will need to add it. On the server, we will add a ",(0,s.kt)("inlineCode",{parentName:"p"},"chat")," field to the ",(0,s.kt)("inlineCode",{parentName:"p"},"Message")," type in the GraphQL schema, and we will implement a resolver which will lookup for the chat in the chats collection:"),(0,s.kt)("h4",{id:"server-step-77-add-messagechat-resolver"},(0,s.kt)("a",{parentName:"h4",href:"https://github.com/Urigo/WhatsApp-Clone-Server/commit/110f7b323478df036680cf2e4f47ffd36d2c86c3"},(0,s.kt)("strong",{parentName:"a"},"Server")," Step 7.7: Add Message.chat resolver")),(0,s.kt)("h5",{id:"changed-schemaresolversts-2"},"Changed schema","/","resolvers.ts"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-diff"},"@@ -6,6 +6,12 @@\n \u250a 6\u250a 6\u250a  Date: DateTimeResolver,\n \u250a 7\u250a 7\u250a  URL: URLResolver,\n \u250a 8\u250a 8\u250a\n+\u250a  \u250a 9\u250a  Message: {\n+\u250a  \u250a10\u250a    chat: (message) => {\n+\u250a  \u250a11\u250a      return chats.find(c => c.messages.some(m => m === message.id)) || null;\n+\u250a  \u250a12\u250a    },\n+\u250a  \u250a13\u250a  },\n+\u250a  \u250a14\u250a\n \u250a 9\u250a15\u250a  Chat: {\n \u250a10\u250a16\u250a    messages: (chat) => {\n \u250a11\u250a17\u250a      return messages.filter((m) => chat.messages.includes(m.id));\n")),(0,s.kt)("h5",{id:"changed-schematypedefsgraphql-1"},"Changed schema","/","typeDefs.graphql"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-diff"},"@@ -5,6 +5,7 @@\n \u250a 5\u250a 5\u250a  id: ID!\n \u250a 6\u250a 6\u250a  content: String!\n \u250a 7\u250a 7\u250a  createdAt: Date!\n+\u250a  \u250a 8\u250a  chat: Chat\n \u250a 8\u250a 9\u250a}\n \u250a 9\u250a10\u250a\n \u250a10\u250a11\u250atype Chat {\n")),(0,s.kt)("p",null,"Now that we have it supported we can update the ",(0,s.kt)("inlineCode",{parentName:"p"},"Message")," fragment in the client to include that information. We don't need the entire chat, only its ID, since the fragment ID composition is done out of an ID and type name:"),(0,s.kt)("h4",{id:"client-step-104-add-chatid-to-message-fragment"},(0,s.kt)("a",{parentName:"h4",href:"https://github.com/Urigo/WhatsApp-Clone-Client-React/commit/62f10e7456f5257423c103faf9a4f6c0a52ce5c0"},(0,s.kt)("strong",{parentName:"a"},"Client")," Step 10.4: Add chat.id to message fragment")),(0,s.kt)("h5",{id:"changed-srccomponentschatroomscreenindextsx-1"},"Changed src","/","components","/","ChatRoomScreen","/","index.tsx"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-diff"},"@@ -68,6 +68,10 @@\n \u250a68\u250a68\u250a            __typename: 'Message',\n \u250a69\u250a69\u250a            id: Math.random().toString(36).substr(2, 9),\n \u250a70\u250a70\u250a            createdAt: new Date(),\n+\u250a  \u250a71\u250a            chat: {\n+\u250a  \u250a72\u250a              __typename: 'Chat',\n+\u250a  \u250a73\u250a              id: chatId,\n+\u250a  \u250a74\u250a            },\n \u250a71\u250a75\u250a            content,\n \u250a72\u250a76\u250a          },\n \u250a73\u250a77\u250a        },\n")),(0,s.kt)("h5",{id:"changed-srccomponentschatslistscreenchatslisttesttsx"},"Changed src","/","components","/","ChatsListScreen","/","ChatsList.test.tsx"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-diff"},"@@ -44,6 +44,10 @@\n \u250a44\u250a44\u250a                  id: 1,\n \u250a45\u250a45\u250a                  content: 'Hello',\n \u250a46\u250a46\u250a                  createdAt: new Date('1 Jan 2019 GMT'),\n+\u250a  \u250a47\u250a                  chat: {\n+\u250a  \u250a48\u250a                    __typename: 'Chat',\n+\u250a  \u250a49\u250a                    id: 1,\n+\u250a  \u250a50\u250a                  },\n \u250a47\u250a51\u250a                },\n \u250a48\u250a52\u250a              },\n \u250a49\u250a53\u250a            ],\n")),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-diff"},"@@ -90,6 +94,10 @@\n \u250a 90\u250a 94\u250a                  id: 1,\n \u250a 91\u250a 95\u250a                  content: 'Hello',\n \u250a 92\u250a 96\u250a                  createdAt: new Date('1 Jan 2019 GMT'),\n+\u250a   \u250a 97\u250a                  chat: {\n+\u250a   \u250a 98\u250a                    __typename: 'Chat',\n+\u250a   \u250a 99\u250a                    id: 1,\n+\u250a   \u250a100\u250a                  },\n \u250a 93\u250a101\u250a                },\n \u250a 94\u250a102\u250a              },\n \u250a 95\u250a103\u250a            ],\n")),(0,s.kt)("h5",{id:"changed-srcgraphqlfragmentsmessagefragmentts"},"Changed src","/","graphql","/","fragments","/","message.fragment.ts"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-diff"},"@@ -5,5 +5,8 @@\n \u250a 5\u250a 5\u250a    id\n \u250a 6\u250a 6\u250a    createdAt\n \u250a 7\u250a 7\u250a    content\n+\u250a  \u250a 8\u250a    chat {\n+\u250a  \u250a 9\u250a      id\n+\u250a  \u250a10\u250a    }\n \u250a 8\u250a11\u250a  }\n \u250a 9\u250a12\u250a`;\n")),(0,s.kt)("p",null,"Finally, we will import the ",(0,s.kt)("inlineCode",{parentName:"p"},"useCacheService")," React hook that we've just created and we will use it in our main ",(0,s.kt)("inlineCode",{parentName:"p"},"App")," component. This means that the cache service will start listening for changes right as the app component is mounted:"),(0,s.kt)("h4",{id:"client-step-105-use-cache-service"},(0,s.kt)("a",{parentName:"h4",href:"https://github.com/Urigo/WhatsApp-Clone-Client-React/commit/cc710f5160cb3a433393413fefbfe9167477c5ff"},(0,s.kt)("strong",{parentName:"a"},"Client")," Step 10.5: Use cache service")),(0,s.kt)("h5",{id:"changed-srcapptsx"},"Changed src","/","App.tsx"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-diff"},'@@ -8,26 +8,31 @@\n \u250a 8\u250a 8\u250aimport ChatRoomScreen from \'./components/ChatRoomScreen\';\n \u250a 9\u250a 9\u250aimport ChatsListScreen from \'./components/ChatsListScreen\';\n+\u250a  \u250a11\u250aimport { useCacheService } from \'./services/cache.service\';\n \u250a11\u250a12\u250a\n-\u250a12\u250a  \u250aconst App: React.FC = () => (\n-\u250a13\u250a  \u250a  <BrowserRouter>\n-\u250a14\u250a  \u250a    <Routes>\n-\u250a15\u250a  \u250a      <Route path="/chats" element={<ChatsListScreen />} />\n+\u250a  \u250a13\u250aconst App: React.FC = () => {\n+\u250a  \u250a14\u250a  useCacheService();\n \u250a16\u250a15\u250a\n-\u250a17\u250a  \u250a      <Route\n-\u250a19\u250a  \u250a        path="/chats/:chatId"\n-\u250a20\u250a  \u250a        element={<ChatRoomScreen />}\n-\u250a26\u250a  \u250a      />\n-\u250a28\u250a  \u250a      <Route path="/" element={<Navigate to="/chats" />} />\n-\u250a27\u250a  \u250a    </Routes>\n-\u250a29\u250a  \u250a  </BrowserRouter>\n-\u250a30\u250a  \u250a);\n+\u250a  \u250a16\u250a  return (\n+\u250a  \u250a17\u250a    <BrowserRouter>\n+\u250a  \u250a18\u250a      <Routes>\n+\u250a  \u250a19\u250a        <Route path="/chats" element={<ChatsListScreen />} />\n+\u250a  \u250a21\u250a        <Route\n+\u250a  \u250a22\u250a          path="/chats/:chatId"\n+\u250a  \u250a23\u250a          element={<ChatRoomScreen />}\n+\u250a  \u250a  \u250a        />\n+\u250a  \u250a  \u250a        <Route path="/" element={<Navigate to="/chats" />} />\n+\u250a  \u250a31\u250a      </Routes>\n+\u250a  \u250a33\u250a    </BrowserRouter>\n+\u250a  \u250a34\u250a  );\n+\u250a  \u250a35\u250a};\n \u250a31\u250a36\u250a\n \u250a32\u250a37\u250aconst redirectToChats = () => <Redirect to="/chats" />;\n')),(0,s.kt)("p",null,"Subscription handling is complete! If you'll try to repeat the same process again where you check messages updating between 2 instances of the app, you should see them both update."),(0,s.kt)("hr",null),(0,s.kt)("p",null,"TODO: ",(0,s.kt)("inlineCode",{parentName:"p"},"useCacheService")," shouldn\u2019t be called like that since it\u2019s related to message events and cache updates are only side-effects."),(0,s.kt)("table",null,(0,s.kt)("thead",{parentName:"table"},(0,s.kt)("tr",{parentName:"thead"},(0,s.kt)("th",{parentName:"tr",align:"left"},(0,s.kt)("a",{parentName:"th",href:"https://github.com/Urigo/WhatsApp-Clone-Tutorial/tree/master@next/.tortilla/manuals/views/step9.md"},"< Previous Step")),(0,s.kt)("th",{parentName:"tr",align:"right"},(0,s.kt)("a",{parentName:"th",href:"https://github.com/Urigo/WhatsApp-Clone-Tutorial/tree/master@next/.tortilla/manuals/views/step11.md"},"Next Step >"))))))}d.isMDXComponent=!0}}]);